<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浮点数的精度</title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="浮点数的精度"><a href="#浮点数的精度" class="headerlink" title="浮点数的精度"></a>浮点数的精度</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="浮点数比较相等"><a href="#浮点数比较相等" class="headerlink" title="浮点数比较相等"></a>浮点数比较相等</h3><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">0.5f</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">0.6f</span>;</span><br><span class="line">    <span class="type">float</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">20</span>) &lt;&lt; c &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1.1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c==1.1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c!=1.1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="number">1.1000000238418579102</span></span><br><span class="line">c!=<span class="number">1.1</span></span><br></pre></td></tr></table></figure><h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><p>将a、b、c变量的类型更换为double后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">0.6</span>;</span><br><span class="line">    <span class="type">double</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">20</span>) &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1.1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c==1.1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c!=1.1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="number">1.1000000000000000888</span></span><br><span class="line">c==<span class="number">1.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> a = <span class="number">15000000.001f</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">15000000.002f</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a==b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a!=b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> c = <span class="number">0.001f</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="number">0.002f</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == d) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c==d&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c!=d&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a==b</span><br><span class="line">c!=d</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数制"><a href="#数制" class="headerlink" title="数制"></a>数制</h2><h3 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h3><p>通常都是基于数字10来书写数字。例如2157的千位是2，百位是l，十位是5，个位是7，可以写成:</p><p><img src="/posts/3ce50156/%E7%BB%8D1.png" alt="浮点数介绍1"></p><p>​$$2×10^3+ 1× 10^2+ 5×10^1+ 7×10^0$$<br>因为这种书写数字的方法是基于10的幂，所以称以10为基底书写2157。</p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>（十进制与二进制的互相转换非本文重点，见文章末尾）</p><h4 id="二进制整数"><a href="#二进制整数" class="headerlink" title="二进制整数"></a>二进制整数</h4><p>计算机适用基底为2的数制系统。它用2的幂而不是10的幂。<strong>以2为基底表示的数字被称为二进制数</strong>。二进制中的2和十进制中的10作用相同。例如，13可用二进制数可表示为:</p><p><img src="/posts/3ce50156/%E7%BB%8D2.png" alt="浮点数介绍2"></p><p>​$$13&#x3D;1×2^3+ 1×2^2+0×2^1+ 1×2^0$$<br>用二进制系统可以把任意整数（如果有足够的位）表示为0和1的组合。</p><h4 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h4><p>二进制数中小数点右侧的部分的表示方法是将每个二进制位乘以 2 的负幂次</p><p><img src="/posts/3ce50156/%E7%BB%8D3.png" alt="浮点数介绍3"></p><p>$$13.625(十进制）&#x3D;1101.101（二进制）&#x3D;1×2^3+ 1×2^2+0×2^1+ 1×2^0+1×2^{-1}+ 0×2^{-2}+1×2^{-3}$$</p><p>这样的表示方式会存在问题，例如0.4、0.6的表示方式：0.4用二进制表示为0.01100110011…（无限循环）、0.6的二进制表示为0.1001100110011…（无限循环）</p><p><strong>某些十进制数小数在二进制中无法精确表示，计算机底层无法精确存储无限循环二进制数，导致舍入误差，这就会在计算机中可能引发精度丢失。</strong></p><h3 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h3><p><img src="/posts/3ce50156/%E7%BB%8D4.png" alt="浮点数介绍4"></p><p><strong>对于任何数字表示成二进制科学计数法以后，一定是1点几（尾数）乘以2的多少次方（指数）</strong>。对于小于零的负数来说，就是负1点几（尾数）乘以2的多少次方（指数）。</p><h2 id="浮点类型的存储"><a href="#浮点类型的存储" class="headerlink" title="浮点类型的存储"></a>浮点类型的存储</h2><p>从数制一章看，要存浮点类型，需要存储三个部分：正负号，尾数，指数。</p><p>在IEEE 754标准中，4字节（单精度浮点数）使用8位作为指数部分，双精度浮点数（8字节）中，使用11位作为指数部分，这个设计是规定的，能在范围和精度之间取得平衡。</p><h3 id="单精度浮点数"><a href="#单精度浮点数" class="headerlink" title="单精度浮点数"></a>单精度浮点数</h3><p>下面以单精度浮点数4字节为例，1位用于符号，8位用于指数，23位用于尾数。</p><ul><li>符号位表示数的符号，0表示正数，1表示负数。</li><li>指数部分存储的是<strong>偏移量形式的指数</strong>。实际指数加上一个偏移量（对于单精度，偏移量为127，对于双精度，偏移量为1023），设置偏移量的主要目的是确保存储的指数部分可以表示为非负整数，从而简化了比较操作和计算过程</li><li>尾数部分存储的是标准化数的有效数字部分，去掉隐含的1，例如，1.101在存储时只保存101部分</li></ul><p><img src="/posts/3ce50156/%E7%BB%8D5.png" alt="浮点数介绍5"></p><p>6.5（十进制）转化为二进制为110.1，用科学计数法表示为$$1.101 × 2^2$$，6.5为正数，所以符号位为<code>0</code>，指数为2，加上偏移量127，为129用二进制表示为<code>1000 0001</code>,尾数部分为101（后补零至23位），即10100000000000000000000，所以6.5以单精度浮点数在内存中的存储方式如下所示</p><p><img src="/posts/3ce50156/%E7%BB%8D6.png" alt="浮点数介绍6"></p><p>-0.4以单精度浮点数在内存中的存储方式如下所示</p><p><img src="/posts/3ce50156/%E7%BB%8D7.png" alt="浮点数介绍7"></p><p><strong>注：</strong>尾数最后一位采用零舍一进，尾数以1001循环，第24位为1，第23位中的1为进位</p><h3 id="双精度浮点数"><a href="#双精度浮点数" class="headerlink" title="双精度浮点数"></a>双精度浮点数</h3><p>组成：符号位（1 位）+ 指数部分（11 位，偏移量为 1023）+尾数（52 位）</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><strong>更高的精度</strong>：双精度使用 52 位尾数，能够表示更小的数值变化，减少舍入误差，适合需要高精度的计算。</li><li><strong>更大范围</strong>：双精度的指数位为 11 位，允许表示的数值范围更广，能够处理更大和更小的数值，适合科学计算和大数据处理。</li><li><strong>更小的精度损失</strong>：在进行多次运算时，使用双精度可以减少因多次舍入导致的精度损失。</li></ol><hr><p><strong>一点</strong>：浮点数在计算机中的内存表示采用指数形式，即 $$\Large 尾数* 2^{指数}$$。这种表示方式决定了浮点数在不同数值量级上的精度表现存在差异。对于绝对值较大的数字，由于指数部分较大，尾数部分的有效位数相对减少，因此小数点后的精度会降低。相反,对于接近 0 的较小数字，指数部分较小，尾数部分的有效位数相对增加，因此小数点后的精度会更高。<a href="#%E4%BE%8B%E4%B8%89">例三</a></p><hr><h2 id="精度解决方式"><a href="#精度解决方式" class="headerlink" title="精度解决方式"></a>精度解决方式</h2><p>使用 <code>double</code> 类型,在计算机中进行浮点数运算时,仍然存在精度问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">0.2</span>;</span><br><span class="line">    <span class="type">double</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">20</span>) &lt;&lt; c &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0.3</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c==0.3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c!=0.3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.3</span></span><br><span class="line"><span class="number">0.30000000000000004441</span></span><br><span class="line">c!=<span class="number">0.3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正确的做法仍然是使用一个合理的容差值来比较浮点数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPSILON 1e-10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">0.2</span>;</span><br><span class="line">    <span class="type">double</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">20</span>) &lt;&lt; c &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(c - <span class="number">0.3</span>) &lt; EPSILON) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c==0.3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c!=0.3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.3</span></span><br><span class="line"><span class="number">0.30000000000000004441</span></span><br><span class="line">c==<span class="number">0.3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="十进制与二进制的相互转换"><a href="#十进制与二进制的相互转换" class="headerlink" title="十进制与二进制的相互转换"></a>十进制与二进制的相互转换</h2><h3 id="从十进制转换为二进制"><a href="#从十进制转换为二进制" class="headerlink" title="从十进制转换为二进制"></a>从十进制转换为二进制</h3><ol><li><strong>整数部分转换</strong>：<ul><li>反复除以2，记录余数，直到商为0。</li></ul></li></ol><ul><li><p>余数从下往上排列即为二进制表示。</p><p> <strong>例</strong>：将13转换为二进制</p><ul><li>13 ÷ 2 &#x3D; 6 余 1</li><li>6 ÷ 2 &#x3D; 3 余 0</li><li>3 ÷ 2 &#x3D; 1 余 1</li><li>1 ÷ 2 &#x3D; 0 余 1</li></ul><p> 从下往上排列：1101</p></li></ul><ol start="2"><li><p><strong>小数部分转换</strong>：</p><ul><li>将小数部分乘以2，记录整数部分，重复此过程直到达到所需精度或小数部分为0。</li></ul><p><strong>例</strong>：将0.625转换为二进制</p><ul><li>0.625 × 2 &#x3D; 1.25 → 1</li><li>0.25 × 2 &#x3D; 0.5 → 0</li><li>0.5 × 2 &#x3D; 1.0 → 1</li></ul><p>所以0.625的二进制是0.101。</p></li></ol><h3 id="从二进制转换为十进制"><a href="#从二进制转换为十进制" class="headerlink" title="从二进制转换为十进制"></a>从二进制转换为十进制</h3><ol><li><p><strong>整数部分转换</strong>：</p><ul><li>每位乘以2的相应幂次，然后相加。</li></ul><p><strong>例</strong>：将1101转换为十进制</p></li></ol><ul><li>$$1 \times 2^3 + 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 &#x3D; 8 + 4 + 0 + 1 &#x3D; 13$$</li></ul><ol start="2"><li><strong>小数部分转换</strong>：</li></ol><ul><li><p>每位乘以2的负相应幂次，然后相加。</p><p> <strong>例</strong>：将0.101转换为十进制</p><ul><li>$$1 \times 2^{-1} + 0 \times 2^{-2} + 1 \times 2^{-3} &#x3D; 0.5 + 0 + 0.125 &#x3D; 0.625$$</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浮点数精度 </tag>
            
            <tag> 浮点数存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/posts/48598499.html"/>
      <url>/posts/48598499.html</url>
      
        <content type="html"><![CDATA[<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="问题抛出"><a href="#问题抛出" class="headerlink" title="问题抛出"></a>问题抛出</h2><p>假设你正在开发一个跨平台的图形界面库，这个库需要在不同的操作系统（如 Windows 和 Mac）上生成按钮。不同操作系统的按钮外观和行为有所不同，因此你不能在创建按钮时简单地使用一个通用的类，如果你直接在代码中硬编码每个操作系统对应的按钮创建逻辑，会导致代码难以维护和扩展。客户端代码例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (os == <span class="string">&quot;Windows&quot;</span>) &#123;</span><br><span class="line">            button = <span class="keyword">new</span> <span class="built_in">WindowsButton</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (os == <span class="string">&quot;Mac&quot;</span>) &#123;</span><br><span class="line">            button = <span class="keyword">new</span> <span class="built_in">MacButton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随着系统的扩展，可能会引入更多的操作系统（如 Linux），这时你需要频繁修改 <code>createButton</code> 函数，违反了 <strong>开闭原则</strong>（对扩展开放，对修改关闭）。这种方法将使代码变得混乱，不易维护。</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>通过一个工厂类来决定实例化哪个具体类，而不是在客户端代码中直接创建对象。简单工厂模式通常用于创建具有相同接口或父类的不同对象。</p><h3 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h3><p>产品（Product）：所有产品类的基类或接口，规定了产品的基本行为。</p><p>具体产品（Concrete Product）：实现产品接口的具体类，代表要创建的对象。</p><p>工厂（Factory）：工厂类负责根据传入的参数，创建相应的产品实例。</p><p><img src="/posts/3ce50156/-Page-1.drawio.png" alt="工厂模式-Page-1.drawio"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rendering Windows Button&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rendering Mac Button&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ButtonFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Button* <span class="title">createButton</span><span class="params">(<span class="type">const</span> std::string&amp; os)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (os == <span class="string">&quot;Windows&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsButton</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (os == <span class="string">&quot;Mac&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MacButton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 默认情况返回空指针或抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端和主函数代码为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">renderButton</span><span class="params">(<span class="type">const</span> std::string&amp; os)</span> </span>&#123;</span><br><span class="line">        Button* button = ButtonFactory::<span class="built_in">createButton</span>(os);</span><br><span class="line">        <span class="keyword">if</span> (button) &#123;</span><br><span class="line">            button-&gt;<span class="built_in">render</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Unsupported OS!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Application app;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态选择创建不同的按钮</span></span><br><span class="line">    std::string os = <span class="string">&quot;Windows&quot;</span>;  <span class="comment">// 根据操作系统决定</span></span><br><span class="line">    app.<span class="built_in">renderButton</span>(os);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>工厂类：将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。</p><p>客户端调用：客户端不直接实例化对象，而是通过调用工厂类的方法来获取对象。</p><p>解耦：客户端和具体类之间的依赖关系被工厂类所隔离，减少了代码的耦合。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>不易扩展</strong>：如果需要增加新的产品类，<strong>需要修改工厂类的逻辑</strong>，违反了“开闭原则”（对扩展开放，对修改关闭）。</p><p><strong>工厂类职责过重</strong>：工厂类集中了所有产品创建的逻辑，随着产品种类的增加，工厂类可能变得非常复杂，导致代码难以维护。</p><h2 id="工厂方法模式-1"><a href="#工厂方法模式-1" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式是一种创建型设计模式，核心思想是将对象的创建过程<strong>抽象化</strong>，不直接在代码中指定要创建的具体类，而是通过工厂类提供的接口或方法来创建对象。这使得系统更加<strong>灵活</strong>，能够轻松扩展新的产品类。</p><h3 id="主要角色-1"><a href="#主要角色-1" class="headerlink" title="主要角色"></a>主要角色</h3><p>抽象工厂（Creator）：声明工厂方法，用来返回一个产品对象。可以是抽象类或接口。</p><p>具体工厂（Concrete Creator）：实现工厂方法，返回具体产品对象的实例。</p><p>抽象产品（Product）：定义产品的接口，是所有具体产品类的父类或接口。</p><p>具体产品（Concrete Product）：实现具体的产品类，由具体工厂创建。</p><p><img src="/posts/3ce50156/-2.drawio.png" alt="工厂模式-第 2 页.drawio"></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rendering Windows Button&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rendering Mac Button&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Button* <span class="title">createButton</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 工厂方法，返回抽象产品类</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">renderButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Button* button = <span class="built_in">createButton</span>();  <span class="comment">// 使用工厂方法创建产品</span></span><br><span class="line">        button-&gt;<span class="built_in">render</span>();                 <span class="comment">// 调用产品的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsDialog</span> : <span class="keyword">public</span> Dialog &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Button* <span class="title">createButton</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsButton</span>();       <span class="comment">// 返回具体产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacDialog</span> : <span class="keyword">public</span> Dialog &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Button* <span class="title">createButton</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MacButton</span>();           <span class="comment">// 返回具体产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户端和主函数代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Dialog* dialog;  <span class="comment">// 引用抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Application</span>(Dialog* dlg) : <span class="built_in">dialog</span>(dlg) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dialog-&gt;<span class="built_in">renderButton</span>();  <span class="comment">// 使用工厂方法创建产品并调用产品的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序时根据不同操作系统创建相应的工厂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dialog* dialog = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设我们动态决定使用哪个工厂，模拟操作系统判断</span></span><br><span class="line">    string os = <span class="string">&quot;Windows&quot;</span>;  <span class="comment">// 可根据系统判断来决定</span></span><br><span class="line">    <span class="keyword">if</span> (os == <span class="string">&quot;Windows&quot;</span>) &#123;</span><br><span class="line">        dialog = <span class="keyword">new</span> <span class="built_in">WindowsDialog</span>();  <span class="comment">// 具体工厂</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (os == <span class="string">&quot;Mac&quot;</span>) &#123;</span><br><span class="line">        dialog = <span class="keyword">new</span> <span class="built_in">MacDialog</span>();      <span class="comment">// 具体工厂</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建应用程序并运行</span></span><br><span class="line">    <span class="function">Application <span class="title">app</span><span class="params">(dialog)</span></span>;</span><br><span class="line">    app.<span class="built_in">run</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="keyword">delete</span> dialog;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p><strong>扩展性好</strong>：当需要支持新的操作系统时，只需添加新的工厂类（如 <code>LinuxDialog</code>），无需修改客户端现有代码。</p><p><strong>遵循开闭原则</strong>：可以通过扩展而不是修改现有代码来实现新功能。</p><p><strong>降低耦合</strong>：客户端代码与具体的产品（按钮）解耦，只与抽象工厂类交互，代码更灵活可维护。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>类的数量增加：每新增一个产品类，就需要增加相应的工厂类，导致系统类的数量增多，增加了系统的复杂性。</p><h2 id="简单工厂与工厂方法的对比"><a href="#简单工厂与工厂方法的对比" class="headerlink" title="简单工厂与工厂方法的对比"></a>简单工厂与工厂方法的对比</h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>简单工厂模式</strong></th><th>工厂方法模式</th></tr></thead><tbody><tr><td><strong>对象创建方式</strong></td><td>客户端直接调用工厂类的静态方法创建具体产品对象。</td><td>客户端依赖于抽象工厂接口，通过具体工厂子类创建具体产品对象。</td></tr><tr><td><strong>客户端与产品耦合度</strong></td><td>客户端代码与工厂类的创建逻辑紧密耦合，客户端需要传递参数并依赖于具体的工厂创建逻辑。</td><td>客户端与产品的创建逻辑解耦，通过工厂接口调用工厂方法，工厂子类决定创建哪个产品。</td></tr><tr><td><strong>扩展性</strong></td><td>增加新产品时需要修改工厂类，可能需要修改客户端传递的参数，扩展性较差。</td><td>增加新产品时只需增加新的具体工厂类，无需修改现有客户端代码，扩展性较好。</td></tr><tr><td><strong>适用场景</strong></td><td>适用于产品种类较少，且变化不频繁的情况。</td><td>适用于产品种类多，且需要经常扩展新产品的情况。</td></tr><tr><td><strong>创建逻辑的复杂性</strong></td><td>创建逻辑集中在工厂类内部，工厂类随着产品类型增多而变得复杂。</td><td>创建逻辑分散在具体工厂类中，不同的工厂类负责不同的产品，符合单一职责原则。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂方法模式 </tag>
            
            <tag> 创建型设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/posts/51bf9e07.html"/>
      <url>/posts/51bf9e07.html</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>单例模式是一种<strong>创建型设计模式</strong>， 它的核心思想是保证<strong>一个类只有一个实例，并提供一个全局访问点来访问这个实例。</strong></p><ul><li>只有一个实例的意思是，在整个应用程序中，只存在该类的一个实例对象，而不是创建多个相同类型的对象。</li><li>全局访问点的意思是，为了让其他类能够获取到这个唯一实例，该类提供了一个全局访问点（通常是一个静态方法），通过这个方法就能获得实例。</li></ul><h2 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h2><p>单例模式的优点包括：</p><ul><li><strong>全局唯一</strong>：确保一个类只有一个实例，提供全局访问点。</li><li><strong>节省资源</strong>：减少内存消耗，避免重复创建对象。多个模块通过单例实例共享数据。</li><li><strong>控制实例化</strong>：方便控制对象的创建过程，例如，延迟初始化，只有在需要时才进行实例化，提高程序的性能。</li></ul><h2 id="单例模式的设计要求"><a href="#单例模式的设计要求" class="headerlink" title="单例模式的设计要求"></a>单例模式的设计要求</h2><p>遵循以下规则：</p><ul><li>私有的构造函数：防止外部代码直接创建类的实例</li><li>私有的静态实例变量：保存该类的唯一实例</li><li>公有的静态方法：通过公有的静态方法来获取类的实例</li><li>线程安全（可选）：如果单例类可能被多个线程同时访问，需要确保实例化过程是线程安全的。例如，可以使用同步机制来防止多个线程同时创建多个实例。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>指系统一运行，就初始化创建实例，当需要时，直接调用即可。<strong>（本身就线程安全，没有多线程的问题）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式-- 饿汉式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有的：静态成员变量，构造函数</span></span><br><span class="line">    <span class="type">static</span> SingleInstance *s;                                   <span class="comment">// 静态成员变量</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>() &#123;&#125;                                         <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance &amp; other) &#123;&#125;              <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    SingleInstance &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SingleInstance &amp;) = <span class="keyword">delete</span>; <span class="comment">// 删除赋值运算符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有的：静态成员函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance *<span class="title">getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SingleInstance *SingleInstance::s = <span class="keyword">new</span> <span class="built_in">SingleInstance</span>(); <span class="comment">// 初始化创建实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 访问静态成员函数方式：1.类名::函数 2 对象.</span></span><br><span class="line">        SingleInstance *S = SingleInstance::<span class="built_in">getinstance</span>();</span><br><span class="line">        cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程环境下，由于饿汉式在程序启动阶段就完成了实例的初始化，因此不存在多个线程同时尝试初始化实例的问题.</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式--懒汉式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 私有的：静态成员变量，构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SingleInstance *s;</span><br><span class="line">    <span class="built_in">SingleInstance</span>() &#123;&#125;                            <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance &amp;other) &#123;&#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance *<span class="title">getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">nullptr</span>)</span><br><span class="line">            s = <span class="keyword">new</span> <span class="built_in">SingleInstance</span>();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SingleInstance *SingleInstance::s = <span class="literal">nullptr</span>; <span class="comment">// 静态成员变量类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SingleInstance *S = SingleInstance::<span class="built_in">getinstance</span>();</span><br><span class="line">        cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>懒汉式</strong>中多个线程同时访问 <code>getInstance()</code> 方法，并且在同一时刻检测到实例没有被创建，就可能会同时创建实例，从而导致多个实例被创建，这种情况下我们可以采用一些同步机制，例如使用互斥锁来确保在任何时刻只有一个线程能够执行实例的创建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SingleInstance *s; <span class="comment">// Static member variable</span></span><br><span class="line">    <span class="type">static</span> mutex mtx;         <span class="comment">// Mutex for thread safety</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>() &#123;&#125;       <span class="comment">// Constructor</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance &amp;other) &#123;&#125; <span class="comment">// Copy constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance *<span class="title">getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// Lock the mutex</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">nullptr</span>) <span class="comment">// Double-check inside the critical section</span></span><br><span class="line">            &#123;</span><br><span class="line">                s = <span class="keyword">new</span> <span class="built_in">SingleInstance</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize static members</span></span><br><span class="line">SingleInstance *SingleInstance::s = <span class="literal">nullptr</span>;</span><br><span class="line">mutex SingleInstance::mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SingleInstance *S = SingleInstance::<span class="built_in">getinstance</span>();</span><br><span class="line">        cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>思考：在C++中单例模式中是否考虑析构函数或者说内存是否泄露？（智能指针）</strong></p><p>推荐的C++懒汉式单例模式-局部静态变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// 局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;constructor called!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;destructor called!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton &amp;instance_1 = Singleton::<span class="built_in">get_instance</span>();</span><br><span class="line">    Singleton &amp;instance_2 = Singleton::<span class="built_in">get_instance</span>();</span><br><span class="line">    cout &lt;&lt; &amp;instance_1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;instance_2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过局部静态变量的特性保证了线程安全 (C++11, GCC &gt; 4.3, VS2015支持该特性);</li><li>不需要使用共享指针，代码简洁；</li><li>注意在使用的时候需要声明单例的引用 Single &amp; 才能获取对象。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>配置管理：统一加载和管理应用程序配置。</li><li>资源管理：管理数据库连接池或线程池等资源。</li><li>日志记录：确保应用程序中只有一个日志实例，避免混乱。</li><li>设备管理：控制硬件设备，确保实例唯一。</li><li>事件调度：统一管理和分发事件。</li><li>缓存管理：管理全局缓存数据，确保一致性。</li><li>线程安全：在多线程环境中控制资源实例的唯一性。</li><li>懒加载：如果对象创建本身就比较消耗资源，而且可能在整个程序中都不一定会使用，可以使用单例模式实现懒加载。</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>小明到了一家大型超市，他拿了一个购物篮开始购物。请设计一个<strong>购物篮管理器</strong>来记录每个添加到购物篮中的商品信息（包括商品名称和购买数量）。在购物完成后，打印出购物篮中的商品清单。（在整个购物过程中，只有一个购物篮实例存在。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShopCarMannage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ShopCarMannage &amp;<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> ShopCarMannage instance; <span class="comment">// 局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addgood</span><span class="params">(string &amp;name, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (info.<span class="built_in">find</span>(name) == info.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            order.<span class="built_in">push_back</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        info[name] += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : order)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; info.<span class="built_in">at</span>(i) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; info;</span><br><span class="line">    vector&lt;string&gt; order;<span class="comment">//保留顺序</span></span><br><span class="line">    <span class="built_in">ShopCarMannage</span>() &#123;cout &lt;&lt; <span class="string">&quot;constructor called!&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="built_in">ShopCarMannage</span>(<span class="type">const</span> ShopCarMannage &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ShopCarMannage &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ShopCarMannage &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">ShopCarMannage</span>() &#123; cout &lt;&lt; <span class="string">&quot;destructor called!&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ShopCarMannage &amp;instance = ShopCarMannage::<span class="built_in">get_instance</span>();</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; name &gt;&gt; num)</span><br><span class="line">    &#123;</span><br><span class="line">        instance.<span class="built_in">addgood</span>(name, num);</span><br><span class="line">    &#125;</span><br><span class="line">    instance.<span class="built_in">printInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selectsort</title>
      <link href="/posts/3ce50156.html"/>
      <url>/posts/3ce50156.html</url>
      
        <content type="html"><![CDATA[<p>每次选择未排序最小值（选择下标）与待排序第一个值交换</p><p><img src="/posts/3ce50156/da16cfb3088e44f6ad8580f19c3ebe21.gif" alt="da16cfb3088e44f6ad8580f19c3ebe21"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;<span class="comment">//外层循环控制循环次数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> minIndex = i;<span class="comment">//minIndex为未排序最小值下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;<span class="comment">//内层循环选择最小值下标</span></span><br><span class="line"><span class="keyword">if</span> (nums[minIndex] &gt; nums[j])minIndex = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(nums[i], nums[minIndex]);<span class="comment">//交换</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次选择未排序最大值（选择下标）与待排序最后一个值交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;<span class="comment">//外层循环控制循环次数</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> j=<span class="number">1</span>,maxIndex=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j;j&lt;nums.<span class="built_in">size</span>()-i;j++)&#123;<span class="comment">//内层循环选择最大值下标</span></span><br><span class="line">            <span class="keyword">if</span>(nums[maxIndex]&lt;nums[j])maxIndex=j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">swap</span>(nums[j<span class="number">-1</span>],nums[maxIndex]);<span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 选择排序 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
