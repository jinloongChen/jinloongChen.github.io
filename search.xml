<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言中的输入输出问题大全</title>
      <link href="/posts/6a1fb5de.html"/>
      <url>/posts/6a1fb5de.html</url>
      
        <content type="html"><![CDATA[<h1 id="C语言中的输入输出"><a href="#C语言中的输入输出" class="headerlink" title="C语言中的输入输出"></a>C语言中的输入输出</h1><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>在C语言中，输入输出缓冲区是提高I&#x2F;O操作效率的一种机制。通过使用缓冲区，程序可以减少直接与硬件（如键盘、显示器或文件）交互的次数，从而提高性能。</p><p>缓冲区是内存中的一块区域，用于临时存储数据。在进行输入输出操作时，数据首先被写入缓冲区，然后再从缓冲区传输到目标设备</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li><strong>全缓冲</strong>：数据在缓冲区满时才进行I&#x2F;O操作，例如是对磁盘文件的读写。</li><li><strong>行缓冲</strong>：当遇到换行符时，数据才会被写入设备。输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的I&#x2F;O 操作。通常情况下，终端（如命令行）就是行缓冲；标准输入(stdin)和标准输出(stdout)就是此类型。</li><li><strong>无缓冲</strong>：数据将立即写入设备，没有缓冲机制。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240926115251294.png" alt="缓冲区"></p><h3 id="刷新缓冲区"><a href="#刷新缓冲区" class="headerlink" title="刷新缓冲区"></a>刷新缓冲区</h3><p><code>fflush()</code> 函数是在 C 语言中用于刷新输出缓冲区的标准库函数。它的主要作用是将缓冲区中的数据强制写入到相应的输出流（如文件或标准输出）。（从缓冲区把数据发送到屏幕或文件被称为<strong>刷新缓冲区</strong>）</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>对于输入流（如 <code>stdin</code>），<code>fflush()</code> 的行为是未定义的，因此不应使用 <code>fflush()</code> 来清空输入缓冲区。</li><li>使用 <code>fflush()</code> 可能会影响程序的性能，因为它会导致系统调用，从而增加 I&#x2F;O 操作的频率。</li></ul><h2 id="格式字符串"><a href="#格式字符串" class="headerlink" title="格式字符串"></a>格式字符串</h2><p>指在编程中用来指定输入或输出数据格式的字符串，通常用于函数如 <code>printf</code> 和 <code>scanf</code> 中。在 C 语言中，格式字符串允许你控制数据的显示方式或如何解析输入。如：printf(格式字符串，待打印项1，待打印项2,… . ) ;</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/%E5%85%A5%E8%BE%93%E5%87%BA.drawio.png" alt="输入输出.drawio"></p><p><strong>格式字符串的组成</strong>：<strong>实际要打印的字符+转换说明</strong></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/%E5%85%A5%E8%BE%93%E5%87%BA2.png" alt="输入输出2"></p><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf()"></a>scanf()</h2><h3 id="scanf-阻塞"><a href="#scanf-阻塞" class="headerlink" title="scanf()阻塞"></a>scanf()阻塞</h3><p>C 语言没有提供输入输出关键字，C 语言的输入和输出通过标准函数库来实现，我们通过scanf 函数读取键盘输入，我们把键盘输入又成为标准输入，当scanf 读取标准输入时，如果没有输入任何内容，那么scanf 会阻塞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c=%c&quot;</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">15</span><br><span class="line">a=15</span><br><span class="line">c=</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先是阻塞，输入15，然后回车，输出a&#x3D;15；<strong>scanf 匹配一个字符，就会在缓冲区删除对应字符</strong>。因为scanf(“%c”,&amp;c)时，不会忽略任何字符，所以scanf(“%c”,&amp;c)读取了还在缓冲区中残留的\n，打印输出了换行</p><h2 id="读取字符"><a href="#读取字符" class="headerlink" title="读取字符"></a>读取字符</h2><h3 id="scanf存在问题"><a href="#scanf存在问题" class="headerlink" title="scanf存在问题"></a>scanf存在问题</h3><p><code>scanf</code>读取数字时会跳过空格、制表符和换行符，而<code>scanf</code> 在读取 <code>%c</code> 时不会自动跳过空白字符（空格、换行、制表符等）。这意味着如果你在读取字符之前已经输入了一个整数或其他内容，可能会因为空白字符(如换行符)而导致读取到不想要的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>, &amp;n, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n=%d,c=%c&quot;</span>,n,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入输出结果</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240926132305467.png" alt="image-20240926132305467"></p><p>使用 <code>%d</code> 来读取整数时，<code>scanf</code> 会跳过前面空白字符并读取到 <code>23</code>，对于 <code>%c</code>，<code>scanf</code> 不会自动跳过空白字符</p><h3 id="c、-c"><a href="#c、-c" class="headerlink" title="%c、 %c"></a>%c、 %c</h3><p><strong>在scanf<a href="#%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2">格式字符串</a>中的转换说明前加空白可跳过下一个输入项前面的所有空白</strong>，即在<code>%c</code>前留一个空白可跳过输入项前的所有空白</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>, &amp;n, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n=%d,c=%c&quot;</span>,n,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入输出结果</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240926135155699.png" alt="image-20240926135155699"></p><ul><li><p><strong>scanf(“%c”,&amp;ch)：从输入中的第1个字符开始读取</strong></p></li><li><p><strong>scanf(“ %c”,&amp;ch)：则从第1个非空白字符</strong></p></li></ul><h3 id="getchar"><a href="#getchar" class="headerlink" title="getchar"></a>getchar</h3><p>通过getchar 可以一次从标准输入读取一个字符，等价于<code>scanf(&quot;&quot;%c&quot;,&amp;c)，</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    c=getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you input alphabet=%c\n&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入输出结果</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240926153331948.png" alt="image-20240926153331948"></p><h3 id="putchar"><a href="#putchar" class="headerlink" title="putchar"></a>putchar</h3><p>putchar()输出字符数据，作用是向显示设备输出一个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a1,a2,a3;</span><br><span class="line">    a1=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    a2=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    a3=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="built_in">putchar</span>(a1);</span><br><span class="line">    <span class="built_in">putchar</span>(a2);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\b&#x27;</span>);<span class="comment">//输出转义字符</span></span><br><span class="line">    <span class="built_in">putchar</span>(a3);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//输出转义字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240926154057003.png" alt="image-20240926154057003"></p><p>关于结果为什么是ac?因为’\b’是退格字符，详情点击<a href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6">转义字符介绍</a></p><h2 id="读取字符串"><a href="#读取字符串" class="headerlink" title="读取字符串"></a>读取字符串</h2><h3 id="scanf读取字符串"><a href="#scanf读取字符串" class="headerlink" title="scanf读取字符串"></a>scanf读取字符串</h3><p>scanf 使用%s读取字符串时，都<strong>从第1个非空白字符作为字符串的开始，以下一个空白字符(空行、空格、制表符或换行符)作为字符串的结束</strong>，即可读取的字符串中不包括空白字符。如果指定了字段宽度，如3s，那么scanf()将读取3个字符或读到其中的空白字符停止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入输出结果</strong></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240926161943247.png" alt="image-20240926161943247"></p><p>scanf从第一个非空白字符’s’开始，直到遇到下空白字符<code>空格</code>作为字符串的结束</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%3s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入输出结果</strong></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240926162146698.png" alt="image-20240926162146698"></p><p>指定了字段宽度为3，在字段宽度内没有出现空白字符，将读取3个字符停止</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%9s&quot;</span>,s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入输出结果</strong></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240926162306911.png" alt="image-20240926162306911"></p><p>指定了字段宽度为9，在字段宽度内出现了空白字符，没有读取到9个字符，而是读到其中的空白字符停止</p><h3 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h3><p>在读取字符串时，<strong>scanf()和转换说明%s只能读取一个单词</strong>。可是在程序中经常要读取一整行输入，而不仅仅是一个单词。</p><p>gets()函数简单易用，它<strong>读取整行输入，直至遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符<code>&#39;\0&#39;</code>使其成为一个C字符串</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240926165323612.png" alt="image-20240926165323612"></p><p><strong>注：gets()不安全，容易导致缓冲区溢出，因为 <code>gets()</code> 不检查输入长度，用户输入的字符数可能超过分配的数组大小，导致内存损坏或安全漏洞。gets()函数在C11标准中已被删除，有些编译器不再支持使用,可使用fgets()、gets_s()可指定最大读取字符数的函数将其替代等。</strong></p><h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h3><p>函数原型：<strong>char * fgets(char * Buf,int MaxCount,FILE * File);</strong></p><p>与gets()不同的是：fgets()函数的第2个参数指明了读入字符的最大数量。<strong>如果该参数的值是n，那么fgets()将读入n-1个字符，或者读到遇到的第一个换行符为止</strong>。<strong>fgets()读到一个换行符，会把它储存在字符串的末尾（在输入行不溢出的情况下），并在其后添加终止符 <code>\0</code>。</strong></p><h4 id="输入行不溢出的情况下"><a href="#输入行不溢出的情况下" class="headerlink" title="输入行不溢出的情况下"></a>输入行不溢出的情况下</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">    fgets(s,<span class="keyword">sizeof</span>(s),<span class="built_in">stdin</span>);<span class="comment">//推荐使用</span></span><br><span class="line">    <span class="built_in">fputs</span>(s,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输入输出结果</strong></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240927221638386.png" alt="image-20240927221638386"></p><p>与puts()不同，<strong>fputs()不会在输出的末尾添加换行符</strong>,但是输出结果依然输出了换行，这是因为<strong>fgets()读取会把换行符储存在字符串的末尾，并在其后添加终止符 <code>\0</code>。</strong>（不溢出的情况下并且输入行的字符个数不为n-1，若输入行的字符刚好为n-1，那么fget()读取的字符串末尾只有<code>\0</code>）</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240927221515792.png" alt="image-20240927221515792"></p><h4 id="输入行溢出的情况下"><a href="#输入行溢出的情况下" class="headerlink" title="输入行溢出的情况下"></a>输入行溢出的情况下</h4><p><strong>或输入行的字符刚好为n-1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">    fgets(s,<span class="number">5</span>,<span class="built_in">stdin</span>);<span class="comment">//推荐使用</span></span><br><span class="line">    <span class="built_in">fputs</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240927113713047.png" alt="image-20240927113713047"></p><p><strong>输入输出结果</strong></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240927114036952.png" alt="image-20240927114036952"></p><p><strong>设置读取的最大数量参数为5，实际上只读取了4个字符,并把<code>hell\0</code>存储在数组中</strong></p><h4 id="实现m-fgets"><a href="#实现m-fgets" class="headerlink" title="实现m_fgets"></a>实现m_fgets</h4><p><code>fgets()</code> 读取字符串时，在输入行(缓冲)未溢出的情况下，读取的字符串中会存在换行符。fgets()储存换行符有好处也有坏处：</p><ul><li>坏处是不想把换行符储存在字符串中，这样的换行符会带来一些麻烦。</li><li>好处是对于储存的字符串而言，检查末尾是否有换行符可以判断是否读取了一整行。如果不是一整行，要妥善处理一行中剩下的字符。</li></ul><p>由上文可知fgets()读取的字符串末尾有两种：</p><ul><li><strong>一种是”\n\0”  (不溢出的情况下并且输入行的字符个数不为n-1)</strong></li><li><strong>一种是’\0’  (溢出的情况下或者输入行字符恰好为n-1)</strong></li></ul><p><strong>如何处理掉换行符?</strong></p><ul><li>如果字符串中出现换行符(不溢出的情况下并且输入行的字符个数不为n-1)，就用空字符替换它</li><li>如果字符串中出现空字符(溢出的情况下或者输入行字符恰好为n-1)，就清除输入行(缓冲)中仍保留的字符</li></ul><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">m_fgets</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span>* ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    ret = fgets(s, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="comment">//遍历字符串，直至遇到换行符或空字符。</span></span><br><span class="line">        <span class="keyword">while</span> (s[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; s[i] != <span class="string">&#x27;\n&#x27;</span>)i++;</span><br><span class="line">        <span class="comment">//如果先遇到换行符，下面的if语句就将其替换成空字符:</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;\n&#x27;</span>) s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//如果先遇到空字符，else部分便丢弃输入行的剩余字符。</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要丢弃过长输入行中的余下字符？丢弃输入行余下的字符<strong>保证了读取语句与键盘输入同步</strong>，输入行中多出来的字符会被留在缓冲区中，成为下一次读取语句的输入。如果下一条读取语句要读取的是double 类型的值，就可能导致程序崩溃。</p><h3 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h3><p>puts 只能用于输出字符串，在末尾添加换行符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240926165750389.png" alt="image-20240926165750389"></p><h2 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h2><p>printf( )语句把输出发送到缓冲区，然后缓冲区中的内容再不断被发送到屏幕上。</p><p><strong>当缓冲区满、遇到换行字符，需要输入或程序结束</strong>的时候才会把缓冲区的内容输出到屏幕上。</p><p>如下代码不会输出到屏幕上(不同编译器结果可能不同)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,C!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,VS!&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240926170456415.png" alt="image-20240926170456415"></p><p><strong>需要刷新输出缓冲区才能正常打印，如在格式字符串的末尾加上换行符、调用fflush()函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,C!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,VS!&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240926170739619.png" alt="image-20240926170739619"></p><hr><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>以“\”开头的特殊字符称为转义字符，转义字符用来表示回车，退格等功能键。</p><h3 id="转义字符列表"><a href="#转义字符列表" class="headerlink" title="转义字符列表"></a>转义字符列表</h3><table><thead><tr><th>转义字符</th><th>名称</th><th>描述</th><th>十进制</th><th>八进制</th></tr></thead><tbody><tr><td><code>\a</code></td><td>响铃 (BEL)</td><td>发出响铃声</td><td>007</td><td>007</td></tr><tr><td><code>\b</code></td><td>退格 (BS)</td><td>将当前位置移到前一列</td><td>008</td><td>008</td></tr><tr><td><code>\n</code></td><td>换行 (LF)</td><td>将当前位置移到下一行开头</td><td>010</td><td>010</td></tr><tr><td><code>\r</code></td><td>回车 (CR)</td><td>将当前位置移到本行开头</td><td>013</td><td>013</td></tr><tr><td><code>\t</code></td><td>水平制表 (HT)</td><td>跳到下一个TAB位置</td><td>009</td><td>009</td></tr><tr><td><code>\v</code></td><td>垂直制表 (VT)</td><td>在垂直方向上跳到下一个TAB位置</td><td>011</td><td>011</td></tr><tr><td><code>\\</code></td><td>反斜线</td><td>代表一个反斜杠字符 <code>\</code></td><td>092</td><td>134</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td><td>代表一个单引号字符</td><td>039</td><td>047</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td><td>代表一个双引号字符</td><td>034</td><td>042</td></tr><tr><td><code>\?</code></td><td>问号</td><td>代表一个问号</td><td>063</td><td>077</td></tr><tr><td><code>\0</code></td><td>空字符 (NUL)</td><td>表示字符串的结束</td><td>000</td><td>000</td></tr><tr><td><code>\ddd</code></td><td>八进制字符</td><td>1到3位八进制数所代表的任意字符</td><td>-</td><td>-</td></tr><tr><td><code>\xhh</code></td><td>十六进制字符</td><td>十六进制所代表的任意字符</td><td>-</td><td>-</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello,\a World!\n&quot;</span>);         <span class="comment">// 响铃</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a t\best.\n&quot;</span>);       <span class="comment">// 退格</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First Line\rSecond Line\n&quot;</span>); <span class="comment">// 回车</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Column 1\tColumn 2\n&quot;</span>);     <span class="comment">// 水平制表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Here is a backslash: \\\n&quot;</span>); <span class="comment">// 反斜线</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Single quote: \&#x27;\n&quot;</span>);         <span class="comment">// 单引号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Double quote: \&quot;\n&quot;</span>);        <span class="comment">// 双引号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Question mark: \?\n&quot;</span>);       <span class="comment">// 问号</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/3ce50156/mage-20240926155356980.png" alt="image-20240926155356980"></p>]]></content>
      
      
      <categories>
          
          <category> C语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scanf读取字符 </tag>
            
            <tag> gets函数的替代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原码、反码、补码</title>
      <link href="/posts/fb35e44.html"/>
      <url>/posts/fb35e44.html</url>
      
        <content type="html"><![CDATA[<h1 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h1><p>全篇以一字节（8位）为例</p><h2 id="机器数和真值"><a href="#机器数和真值" class="headerlink" title="机器数和真值"></a>机器数和真值</h2><p><strong>机器数</strong>：一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，最高位存放符号, 正数为0, 负数为1。如数<code>5</code>、<code>-5</code>（十进制）分别转换成8位二进制为<code>0000 0101</code>、<code>10000101</code></p><p><strong>真值</strong>：将带符号位的机器数对应的<strong>真正数值</strong>称为机器数的真值。如有符号数<code>10000101</code>真正数值为<code>-5</code>,而不是133</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p><strong>定义</strong>：最高位为符号位，1 表示负数，0 表示正数。其余比特位表示值。</p><ul><li><p>+5[原码]: 0000 0101</p></li><li><p>-5[原码]:  1000 0101</p></li></ul><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><h4 id="负数计算出错"><a href="#负数计算出错" class="headerlink" title="负数计算出错"></a>负数计算出错</h4><p>使用原码计算<code>5-3</code>：</p><p>假设我们要计算 (5 - 3) 的原码表示。</p><ol><li><p><strong>表示数字</strong>：</p><ul><li>(5) 的原码是 <code>0000 0101</code>（正数）。</li><li>(3) 的原码是 <code>0000 0011</code>（正数）。</li></ul></li><li><p><strong>取负数</strong>：</p></li></ol><ul><li>( -3 ) 的原码是 <code>1000 0011</code>（负数）。</li></ul><ol start="4"><li><p><strong>计算</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   0000 0101</span><br><span class="line">+  1000 0011</span><br><span class="line">---------------</span><br><span class="line">   1000 1000</span><br></pre></td></tr></table></figure></li><li><p><strong>结果分析</strong>：</p><ul><li>结果 <code>1000 1000</code> 表示负数，得到的真值是 -8。结果不正确，原码在减法操作中的复杂性和易出错性。</li></ul></li></ol><h4 id="零不唯一"><a href="#零不唯一" class="headerlink" title="零不唯一"></a>零不唯一</h4><p>在原码表示中，零的表示确实是不唯一的。</p><ol><li><p><strong>正零</strong>：</p><ul><li>正零的原码表示为 <code>0000 0000</code>（最高位为0）。</li></ul></li><li><p><strong>负零</strong>：</p><ul><li>负零的原码表示为 <code>1000 0000</code>（最高位为1）。</li></ul></li></ol><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>正数的反码与原码相同，而负数的反码是对原码中<strong>数值位</strong>每一位进行取反</p><ul><li>+5 [反码]：00000101（与原码相同）</li><li>-5 [反码]：<ul><li>原码：    10000101</li><li>反码：    11111010（数值部分每位取反）</li></ul></li></ul><h3 id="反码计算"><a href="#反码计算" class="headerlink" title="反码计算"></a>反码计算</h3><p>1.反码运算时，其符号位与数值一起参加运算。</p><p>2.反码的符号位相加后，如果有进位出现，则要把它送回到最低位去相加（循环进位）。</p><p>3.用反码运算，其运算结果亦为反码。在转换为真值时，若符号位为0，数位不变；若符号位为1，应将结果求反才是其真值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0000 0101  (5)</span><br><span class="line">+ 1111 1100  (-3的反码)</span><br><span class="line">---------------</span><br><span class="line"> 10000 0001---&gt;0000 0001----进位加到最低位--&gt;0000 0010</span><br></pre></td></tr></table></figure><p>0000 0010的真值为2，结果正确</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="零不唯一-1"><a href="#零不唯一-1" class="headerlink" title="零不唯一"></a>零不唯一</h4><p>反码有正零（0000000000000000 ）和负零（1111111111111111）两个表示</p><h4 id="加法复杂性"><a href="#加法复杂性" class="headerlink" title="加法复杂性"></a>加法复杂性</h4><p>在反码加法中，必须处理进位和符号位，增加了运算的复杂性。</p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>正数的补码和它的原码相同，负数的补码 &#x3D; 数值位逐位求反(反码) + 1   （+1是在最后的位置加一，即使是小数的最后位置）</p><p>补码的第一位不仅代表符号位，还代表了权值</p><ul><li><p>+5[补码]&#x3D; 0000 0101</p></li><li><p>-5[补码]:</p><ul><li>原码：    10000101</li><li>反码：    11111010（数值部分每位取反）</li><li>补码：    1111 1011  （反码+1）</li></ul></li></ul><h3 id="例：小数的补码"><a href="#例：小数的补码" class="headerlink" title="例：小数的补码"></a>例：小数的补码</h3><ol><li><p><strong>正数 5.625 的二进制表示</strong>：</p><ul><li>整数部分 5 &#x3D; 101</li></ul></li></ol><ul><li>小数部分 0.625 &#x3D; 0.101（通过反复乘以 2 得到）</li></ul><p>所以，5.625 的原码为：<code>101.101</code></p><ol start="2"><li><p><strong>表示为补码</strong>：</p><ul><li>首先，正数 5.625 的原码为 <code>00000101.101</code>（假设使用 8 位整数部分和 3 位小数部分）。</li><li>反码（对符号位不变，数值部分取反）：<ul><li>整数部分取反：<code>11111010.010</code></li></ul></li><li>补码（反码 + 1）：<ul><li><code>11111010.010</code> + <code>0.001</code> &#x3D; <code>11111010.011</code></li></ul></li></ul><p><strong>-5.625 的补码为 <code>11111010.011</code></strong></p></li></ol><h3 id="零唯一"><a href="#零唯一" class="headerlink" title="零唯一"></a>零唯一</h3><p>零的表示是唯一的，即 0000 0000，正零和负零都用相同的表示，这样避免了反码中存在的两个零表示的问题</p><h3 id="补码计算"><a href="#补码计算" class="headerlink" title="补码计算"></a>补码计算</h3><p>计算 (5 - 3) 的补码方法如下：</p><ol><li><p><strong>表示 (5)</strong>：</p><ul><li>原码：(0000 0101)</li><li>补码：(0000 0101)</li></ul></li><li><p><strong>表示 (-3)</strong>：</p><ul><li><p>原码：(1000 0011)</p></li><li><p>反码：(1111 1100)</p></li><li><p>补码：(1111 1101)（反码加 (1)）</p></li></ul></li><li><p><strong>相加</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  0000 0101  (5)</span><br><span class="line">+ 1111 1101  (-3的反码)</span><br><span class="line">1 0000 0010 ----舍去进位----&gt;0000 0010 </span><br></pre></td></tr></table></figure></li></ol><p>结果是 (0000 0010)，即 2，表示 5 - 3 &#x3D; 2，结果正确。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反码计算 </tag>
            
            <tag> 补码计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浮点数的精度</title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="浮点数的精度"><a href="#浮点数的精度" class="headerlink" title="浮点数的精度"></a>浮点数的精度</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="浮点数比较相等"><a href="#浮点数比较相等" class="headerlink" title="浮点数比较相等"></a>浮点数比较相等</h3><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">0.5f</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">0.6f</span>;</span><br><span class="line">    <span class="type">float</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">20</span>) &lt;&lt; c &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1.1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c==1.1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c!=1.1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="number">1.1000000238418579102</span></span><br><span class="line">c!=<span class="number">1.1</span></span><br></pre></td></tr></table></figure><h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><p>将a、b、c变量的类型更换为double后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">0.6</span>;</span><br><span class="line">    <span class="type">double</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">20</span>) &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1.1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c==1.1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c!=1.1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="number">1.1000000000000000888</span></span><br><span class="line">c==<span class="number">1.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> a = <span class="number">15000000.001f</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">15000000.002f</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a==b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a!=b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> c = <span class="number">0.001f</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="number">0.002f</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == d) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c==d&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c!=d&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a==b</span><br><span class="line">c!=d</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数制"><a href="#数制" class="headerlink" title="数制"></a>数制</h2><h3 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h3><p>通常都是基于数字10来书写数字。例如2157的千位是2，百位是l，十位是5，个位是7，可以写成:</p><p><img src="/posts/3ce50156/%E7%BB%8D1.png" alt="浮点数介绍1"></p><p>​$$2×10^3+ 1× 10^2+ 5×10^1+ 7×10^0$$<br>因为这种书写数字的方法是基于10的幂，所以称以10为基底书写2157。</p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>（十进制与二进制的互相转换非本文重点，见文章末尾）</p><h4 id="二进制整数"><a href="#二进制整数" class="headerlink" title="二进制整数"></a>二进制整数</h4><p>计算机适用基底为2的数制系统。它用2的幂而不是10的幂。<strong>以2为基底表示的数字被称为二进制数</strong>。二进制中的2和十进制中的10作用相同。例如，13可用二进制数可表示为:</p><p><img src="/posts/3ce50156/%E7%BB%8D2.png" alt="浮点数介绍2"></p><p>​$$13&#x3D;1×2^3+ 1×2^2+0×2^1+ 1×2^0$$<br>用二进制系统可以把任意整数（如果有足够的位）表示为0和1的组合。</p><h4 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h4><p>二进制数中小数点右侧的部分的表示方法是将每个二进制位乘以 2 的负幂次</p><p><img src="/posts/3ce50156/%E7%BB%8D3.png" alt="浮点数介绍3"></p><p>$$13.625(十进制）&#x3D;1101.101（二进制）&#x3D;1×2^3+ 1×2^2+0×2^1+ 1×2^0+1×2^{-1}+ 0×2^{-2}+1×2^{-3}$$</p><p>这样的表示方式会存在问题，例如0.4、0.6的表示方式：0.4用二进制表示为0.01100110011…（无限循环）、0.6的二进制表示为0.1001100110011…（无限循环）</p><p><strong>某些十进制数小数在二进制中无法精确表示，计算机底层无法精确存储无限循环二进制数，导致舍入误差，这就会在计算机中可能引发精度丢失。</strong></p><h3 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h3><p><img src="/posts/3ce50156/%E7%BB%8D4.png" alt="浮点数介绍4"></p><p><strong>对于任何数字表示成二进制科学计数法以后，一定是1点几（尾数）乘以2的多少次方（指数）</strong>。对于小于零的负数来说，就是负1点几（尾数）乘以2的多少次方（指数）。</p><h2 id="浮点类型的存储"><a href="#浮点类型的存储" class="headerlink" title="浮点类型的存储"></a>浮点类型的存储</h2><p>从数制一章看，要存浮点类型，需要存储三个部分：正负号，尾数，指数。</p><p>在IEEE 754标准中，4字节（单精度浮点数）使用8位作为指数部分，双精度浮点数（8字节）中，使用11位作为指数部分，这个设计是规定的，能在范围和精度之间取得平衡。</p><h3 id="单精度浮点数"><a href="#单精度浮点数" class="headerlink" title="单精度浮点数"></a>单精度浮点数</h3><p>下面以单精度浮点数4字节为例，1位用于符号，8位用于指数，23位用于尾数。</p><ul><li>符号位表示数的符号，0表示正数，1表示负数。</li><li>指数部分存储的是<strong>偏移量形式的指数</strong>。实际指数加上一个偏移量（对于单精度，偏移量为127，对于双精度，偏移量为1023），设置偏移量的主要目的是确保存储的指数部分可以表示为非负整数，从而简化了比较操作和计算过程</li><li>尾数部分存储的是标准化数的有效数字部分，去掉隐含的1，例如，1.101在存储时只保存101部分</li></ul><p><img src="/posts/3ce50156/%E7%BB%8D5.png" alt="浮点数介绍5"></p><p>6.5（十进制）转化为二进制为110.1，用科学计数法表示为$$1.101 × 2^2$$，6.5为正数，所以符号位为<code>0</code>，指数为2，加上偏移量127，为129用二进制表示为<code>1000 0001</code>,尾数部分为101（后补零至23位），即10100000000000000000000，所以6.5以单精度浮点数在内存中的存储方式如下所示</p><p><img src="/posts/3ce50156/%E7%BB%8D6.png" alt="浮点数介绍6"></p><p>-0.4以单精度浮点数在内存中的存储方式如下所示</p><p><img src="/posts/3ce50156/%E7%BB%8D7.png" alt="浮点数介绍7"></p><p><strong>注：</strong>尾数最后一位采用零舍一进，尾数以1001循环，第24位为1，第23位中的1为进位</p><h3 id="双精度浮点数"><a href="#双精度浮点数" class="headerlink" title="双精度浮点数"></a>双精度浮点数</h3><p>组成：符号位（1 位）+ 指数部分（11 位，偏移量为 1023）+尾数（52 位）</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><strong>更高的精度</strong>：双精度使用 52 位尾数，能够表示更小的数值变化，减少舍入误差，适合需要高精度的计算。</li><li><strong>更大范围</strong>：双精度的指数位为 11 位，允许表示的数值范围更广，能够处理更大和更小的数值，适合科学计算和大数据处理。</li><li><strong>更小的精度损失</strong>：在进行多次运算时，使用双精度可以减少因多次舍入导致的精度损失。</li></ol><hr><p><strong>一点</strong>：浮点数在计算机中的内存表示采用指数形式，即 $$\Large 尾数* 2^{指数}$$。这种表示方式决定了浮点数在不同数值量级上的精度表现存在差异。对于绝对值较大的数字，由于指数部分较大，尾数部分的有效位数相对减少，因此小数点后的精度会降低。相反,对于接近 0 的较小数字，指数部分较小，尾数部分的有效位数相对增加，因此小数点后的精度会更高。<a href="#%E4%BE%8B%E4%B8%89">例三</a></p><hr><h2 id="精度解决方式"><a href="#精度解决方式" class="headerlink" title="精度解决方式"></a>精度解决方式</h2><p>使用 <code>double</code> 类型,在计算机中进行浮点数运算时,仍然存在精度问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">0.2</span>;</span><br><span class="line">    <span class="type">double</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">20</span>) &lt;&lt; c &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0.3</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c==0.3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c!=0.3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.3</span></span><br><span class="line"><span class="number">0.30000000000000004441</span></span><br><span class="line">c!=<span class="number">0.3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正确的做法仍然是使用一个合理的容差值来比较浮点数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPSILON 1e-10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">0.2</span>;</span><br><span class="line">    <span class="type">double</span> c = a + b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">20</span>) &lt;&lt; c &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(c - <span class="number">0.3</span>) &lt; EPSILON) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c==0.3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c!=0.3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.3</span></span><br><span class="line"><span class="number">0.30000000000000004441</span></span><br><span class="line">c==<span class="number">0.3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="十进制与二进制的相互转换"><a href="#十进制与二进制的相互转换" class="headerlink" title="十进制与二进制的相互转换"></a>十进制与二进制的相互转换</h2><h3 id="从十进制转换为二进制"><a href="#从十进制转换为二进制" class="headerlink" title="从十进制转换为二进制"></a>从十进制转换为二进制</h3><ol><li><strong>整数部分转换</strong>：<ul><li>反复除以2，记录余数，直到商为0。</li></ul></li></ol><ul><li><p>余数从下往上排列即为二进制表示。</p><p> <strong>例</strong>：将13转换为二进制</p><ul><li>13 ÷ 2 &#x3D; 6 余 1</li><li>6 ÷ 2 &#x3D; 3 余 0</li><li>3 ÷ 2 &#x3D; 1 余 1</li><li>1 ÷ 2 &#x3D; 0 余 1</li></ul><p> 从下往上排列：1101</p></li></ul><ol start="2"><li><p><strong>小数部分转换</strong>：</p><ul><li>将小数部分乘以2，记录整数部分，重复此过程直到达到所需精度或小数部分为0。</li></ul><p><strong>例</strong>：将0.625转换为二进制</p><ul><li>0.625 × 2 &#x3D; 1.25 → 1</li><li>0.25 × 2 &#x3D; 0.5 → 0</li><li>0.5 × 2 &#x3D; 1.0 → 1</li></ul><p>所以0.625的二进制是0.101。</p></li></ol><h3 id="从二进制转换为十进制"><a href="#从二进制转换为十进制" class="headerlink" title="从二进制转换为十进制"></a>从二进制转换为十进制</h3><ol><li><p><strong>整数部分转换</strong>：</p><ul><li>每位乘以2的相应幂次，然后相加。</li></ul><p><strong>例</strong>：将1101转换为十进制</p></li></ol><ul><li>$$1 \times 2^3 + 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 &#x3D; 8 + 4 + 0 + 1 &#x3D; 13$$</li></ul><ol start="2"><li><strong>小数部分转换</strong>：</li></ol><ul><li><p>每位乘以2的负相应幂次，然后相加。</p><p> <strong>例</strong>：将0.101转换为十进制</p><ul><li>$$1 \times 2^{-1} + 0 \times 2^{-2} + 1 \times 2^{-3} &#x3D; 0.5 + 0 + 0.125 &#x3D; 0.625$$</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浮点数精度 </tag>
            
            <tag> 浮点数存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/posts/48598499.html"/>
      <url>/posts/48598499.html</url>
      
        <content type="html"><![CDATA[<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="问题抛出"><a href="#问题抛出" class="headerlink" title="问题抛出"></a>问题抛出</h2><p>假设你正在开发一个跨平台的图形界面库，这个库需要在不同的操作系统（如 Windows 和 Mac）上生成按钮。不同操作系统的按钮外观和行为有所不同，因此你不能在创建按钮时简单地使用一个通用的类，如果你直接在代码中硬编码每个操作系统对应的按钮创建逻辑，会导致代码难以维护和扩展。客户端代码例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (os == <span class="string">&quot;Windows&quot;</span>) &#123;</span><br><span class="line">            button = <span class="keyword">new</span> <span class="built_in">WindowsButton</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (os == <span class="string">&quot;Mac&quot;</span>) &#123;</span><br><span class="line">            button = <span class="keyword">new</span> <span class="built_in">MacButton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随着系统的扩展，可能会引入更多的操作系统（如 Linux），这时你需要频繁修改 <code>createButton</code> 函数，违反了 <strong>开闭原则</strong>（对扩展开放，对修改关闭）。这种方法将使代码变得混乱，不易维护。</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>通过一个工厂类来决定实例化哪个具体类，而不是在客户端代码中直接创建对象。简单工厂模式通常用于创建具有相同接口或父类的不同对象。</p><h3 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h3><p>产品（Product）：所有产品类的基类或接口，规定了产品的基本行为。</p><p>具体产品（Concrete Product）：实现产品接口的具体类，代表要创建的对象。</p><p>工厂（Factory）：工厂类负责根据传入的参数，创建相应的产品实例。</p><p><img src="/posts/3ce50156/-Page-1.drawio.png" alt="工厂模式-Page-1.drawio"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rendering Windows Button&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rendering Mac Button&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ButtonFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Button* <span class="title">createButton</span><span class="params">(<span class="type">const</span> std::string&amp; os)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (os == <span class="string">&quot;Windows&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsButton</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (os == <span class="string">&quot;Mac&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MacButton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 默认情况返回空指针或抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端和主函数代码为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">renderButton</span><span class="params">(<span class="type">const</span> std::string&amp; os)</span> </span>&#123;</span><br><span class="line">        Button* button = ButtonFactory::<span class="built_in">createButton</span>(os);</span><br><span class="line">        <span class="keyword">if</span> (button) &#123;</span><br><span class="line">            button-&gt;<span class="built_in">render</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Unsupported OS!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Application app;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态选择创建不同的按钮</span></span><br><span class="line">    std::string os = <span class="string">&quot;Windows&quot;</span>;  <span class="comment">// 根据操作系统决定</span></span><br><span class="line">    app.<span class="built_in">renderButton</span>(os);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>工厂类：将产品的创建过程封装在一个工厂类中，把创建对象的流程集中在这个工厂类里面。</p><p>客户端调用：客户端不直接实例化对象，而是通过调用工厂类的方法来获取对象。</p><p>解耦：客户端和具体类之间的依赖关系被工厂类所隔离，减少了代码的耦合。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>不易扩展</strong>：如果需要增加新的产品类，<strong>需要修改工厂类的逻辑</strong>，违反了“开闭原则”（对扩展开放，对修改关闭）。</p><p><strong>工厂类职责过重</strong>：工厂类集中了所有产品创建的逻辑，随着产品种类的增加，工厂类可能变得非常复杂，导致代码难以维护。</p><h2 id="工厂方法模式-1"><a href="#工厂方法模式-1" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式是一种创建型设计模式，核心思想是将对象的创建过程<strong>抽象化</strong>，不直接在代码中指定要创建的具体类，而是通过工厂类提供的接口或方法来创建对象。这使得系统更加<strong>灵活</strong>，能够轻松扩展新的产品类。</p><h3 id="主要角色-1"><a href="#主要角色-1" class="headerlink" title="主要角色"></a>主要角色</h3><p>抽象工厂（Creator）：声明工厂方法，用来返回一个产品对象。可以是抽象类或接口。</p><p>具体工厂（Concrete Creator）：实现工厂方法，返回具体产品对象的实例。</p><p>抽象产品（Product）：定义产品的接口，是所有具体产品类的父类或接口。</p><p>具体产品（Concrete Product）：实现具体的产品类，由具体工厂创建。</p><p><img src="/posts/3ce50156/-2.drawio.png" alt="工厂模式-第 2 页.drawio"></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">render</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rendering Windows Button&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> : <span class="keyword">public</span> Button &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rendering Mac Button&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dialog</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Button* <span class="title">createButton</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 工厂方法，返回抽象产品类</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">renderButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Button* button = <span class="built_in">createButton</span>();  <span class="comment">// 使用工厂方法创建产品</span></span><br><span class="line">        button-&gt;<span class="built_in">render</span>();                 <span class="comment">// 调用产品的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsDialog</span> : <span class="keyword">public</span> Dialog &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Button* <span class="title">createButton</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsButton</span>();       <span class="comment">// 返回具体产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacDialog</span> : <span class="keyword">public</span> Dialog &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Button* <span class="title">createButton</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MacButton</span>();           <span class="comment">// 返回具体产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户端和主函数代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Dialog* dialog;  <span class="comment">// 引用抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Application</span>(Dialog* dlg) : <span class="built_in">dialog</span>(dlg) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dialog-&gt;<span class="built_in">renderButton</span>();  <span class="comment">// 使用工厂方法创建产品并调用产品的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序时根据不同操作系统创建相应的工厂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dialog* dialog = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设我们动态决定使用哪个工厂，模拟操作系统判断</span></span><br><span class="line">    string os = <span class="string">&quot;Windows&quot;</span>;  <span class="comment">// 可根据系统判断来决定</span></span><br><span class="line">    <span class="keyword">if</span> (os == <span class="string">&quot;Windows&quot;</span>) &#123;</span><br><span class="line">        dialog = <span class="keyword">new</span> <span class="built_in">WindowsDialog</span>();  <span class="comment">// 具体工厂</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (os == <span class="string">&quot;Mac&quot;</span>) &#123;</span><br><span class="line">        dialog = <span class="keyword">new</span> <span class="built_in">MacDialog</span>();      <span class="comment">// 具体工厂</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建应用程序并运行</span></span><br><span class="line">    <span class="function">Application <span class="title">app</span><span class="params">(dialog)</span></span>;</span><br><span class="line">    app.<span class="built_in">run</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="keyword">delete</span> dialog;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p><strong>扩展性好</strong>：当需要支持新的操作系统时，只需添加新的工厂类（如 <code>LinuxDialog</code>），无需修改客户端现有代码。</p><p><strong>遵循开闭原则</strong>：可以通过扩展而不是修改现有代码来实现新功能。</p><p><strong>降低耦合</strong>：客户端代码与具体的产品（按钮）解耦，只与抽象工厂类交互，代码更灵活可维护。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>类的数量增加：每新增一个产品类，就需要增加相应的工厂类，导致系统类的数量增多，增加了系统的复杂性。</p><h2 id="简单工厂与工厂方法的对比"><a href="#简单工厂与工厂方法的对比" class="headerlink" title="简单工厂与工厂方法的对比"></a>简单工厂与工厂方法的对比</h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>简单工厂模式</strong></th><th>工厂方法模式</th></tr></thead><tbody><tr><td><strong>对象创建方式</strong></td><td>客户端直接调用工厂类的静态方法创建具体产品对象。</td><td>客户端依赖于抽象工厂接口，通过具体工厂子类创建具体产品对象。</td></tr><tr><td><strong>客户端与产品耦合度</strong></td><td>客户端代码与工厂类的创建逻辑紧密耦合，客户端需要传递参数并依赖于具体的工厂创建逻辑。</td><td>客户端与产品的创建逻辑解耦，通过工厂接口调用工厂方法，工厂子类决定创建哪个产品。</td></tr><tr><td><strong>扩展性</strong></td><td>增加新产品时需要修改工厂类，可能需要修改客户端传递的参数，扩展性较差。</td><td>增加新产品时只需增加新的具体工厂类，无需修改现有客户端代码，扩展性较好。</td></tr><tr><td><strong>适用场景</strong></td><td>适用于产品种类较少，且变化不频繁的情况。</td><td>适用于产品种类多，且需要经常扩展新产品的情况。</td></tr><tr><td><strong>创建逻辑的复杂性</strong></td><td>创建逻辑集中在工厂类内部，工厂类随着产品类型增多而变得复杂。</td><td>创建逻辑分散在具体工厂类中，不同的工厂类负责不同的产品，符合单一职责原则。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂方法模式 </tag>
            
            <tag> 创建型设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/posts/51bf9e07.html"/>
      <url>/posts/51bf9e07.html</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>单例模式是一种<strong>创建型设计模式</strong>， 它的核心思想是保证<strong>一个类只有一个实例，并提供一个全局访问点来访问这个实例。</strong></p><ul><li>只有一个实例的意思是，在整个应用程序中，只存在该类的一个实例对象，而不是创建多个相同类型的对象。</li><li>全局访问点的意思是，为了让其他类能够获取到这个唯一实例，该类提供了一个全局访问点（通常是一个静态方法），通过这个方法就能获得实例。</li></ul><h2 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h2><p>单例模式的优点包括：</p><ul><li><strong>全局唯一</strong>：确保一个类只有一个实例，提供全局访问点。</li><li><strong>节省资源</strong>：减少内存消耗，避免重复创建对象。多个模块通过单例实例共享数据。</li><li><strong>控制实例化</strong>：方便控制对象的创建过程，例如，延迟初始化，只有在需要时才进行实例化，提高程序的性能。</li></ul><h2 id="单例模式的设计要求"><a href="#单例模式的设计要求" class="headerlink" title="单例模式的设计要求"></a>单例模式的设计要求</h2><p>遵循以下规则：</p><ul><li>私有的构造函数：防止外部代码直接创建类的实例</li><li>私有的静态实例变量：保存该类的唯一实例</li><li>公有的静态方法：通过公有的静态方法来获取类的实例</li><li>线程安全（可选）：如果单例类可能被多个线程同时访问，需要确保实例化过程是线程安全的。例如，可以使用同步机制来防止多个线程同时创建多个实例。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>指系统一运行，就初始化创建实例，当需要时，直接调用即可。<strong>（本身就线程安全，没有多线程的问题）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式-- 饿汉式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有的：静态成员变量，构造函数</span></span><br><span class="line">    <span class="type">static</span> SingleInstance *s;                                   <span class="comment">// 静态成员变量</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>() &#123;&#125;                                         <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance &amp; other) &#123;&#125;              <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    SingleInstance &amp;<span class="keyword">operator</span>=(<span class="type">const</span> SingleInstance &amp;) = <span class="keyword">delete</span>; <span class="comment">// 删除赋值运算符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有的：静态成员函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance *<span class="title">getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SingleInstance *SingleInstance::s = <span class="keyword">new</span> <span class="built_in">SingleInstance</span>(); <span class="comment">// 初始化创建实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 访问静态成员函数方式：1.类名::函数 2 对象.</span></span><br><span class="line">        SingleInstance *S = SingleInstance::<span class="built_in">getinstance</span>();</span><br><span class="line">        cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程环境下，由于饿汉式在程序启动阶段就完成了实例的初始化，因此不存在多个线程同时尝试初始化实例的问题.</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式--懒汉式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 私有的：静态成员变量，构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SingleInstance *s;</span><br><span class="line">    <span class="built_in">SingleInstance</span>() &#123;&#125;                            <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance &amp;other) &#123;&#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance *<span class="title">getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">nullptr</span>)</span><br><span class="line">            s = <span class="keyword">new</span> <span class="built_in">SingleInstance</span>();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SingleInstance *SingleInstance::s = <span class="literal">nullptr</span>; <span class="comment">// 静态成员变量类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SingleInstance *S = SingleInstance::<span class="built_in">getinstance</span>();</span><br><span class="line">        cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>懒汉式</strong>中多个线程同时访问 <code>getInstance()</code> 方法，并且在同一时刻检测到实例没有被创建，就可能会同时创建实例，从而导致多个实例被创建，这种情况下我们可以采用一些同步机制，例如使用互斥锁来确保在任何时刻只有一个线程能够执行实例的创建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SingleInstance *s; <span class="comment">// Static member variable</span></span><br><span class="line">    <span class="type">static</span> mutex mtx;         <span class="comment">// Mutex for thread safety</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>() &#123;&#125;       <span class="comment">// Constructor</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance &amp;other) &#123;&#125; <span class="comment">// Copy constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance *<span class="title">getinstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>; <span class="comment">// Lock the mutex</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">nullptr</span>) <span class="comment">// Double-check inside the critical section</span></span><br><span class="line">            &#123;</span><br><span class="line">                s = <span class="keyword">new</span> <span class="built_in">SingleInstance</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize static members</span></span><br><span class="line">SingleInstance *SingleInstance::s = <span class="literal">nullptr</span>;</span><br><span class="line">mutex SingleInstance::mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SingleInstance *S = SingleInstance::<span class="built_in">getinstance</span>();</span><br><span class="line">        cout &lt;&lt; S &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>思考：在C++中单例模式中是否考虑析构函数或者说内存是否泄露？（智能指针）</strong></p><p>推荐的C++懒汉式单例模式-局部静态变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton &amp;<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// 局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;constructor called!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123; cout &lt;&lt; <span class="string">&quot;destructor called!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton &amp;instance_1 = Singleton::<span class="built_in">get_instance</span>();</span><br><span class="line">    Singleton &amp;instance_2 = Singleton::<span class="built_in">get_instance</span>();</span><br><span class="line">    cout &lt;&lt; &amp;instance_1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;instance_2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过局部静态变量的特性保证了线程安全 (C++11, GCC &gt; 4.3, VS2015支持该特性);</li><li>不需要使用共享指针，代码简洁；</li><li>注意在使用的时候需要声明单例的引用 Single &amp; 才能获取对象。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>配置管理：统一加载和管理应用程序配置。</li><li>资源管理：管理数据库连接池或线程池等资源。</li><li>日志记录：确保应用程序中只有一个日志实例，避免混乱。</li><li>设备管理：控制硬件设备，确保实例唯一。</li><li>事件调度：统一管理和分发事件。</li><li>缓存管理：管理全局缓存数据，确保一致性。</li><li>线程安全：在多线程环境中控制资源实例的唯一性。</li><li>懒加载：如果对象创建本身就比较消耗资源，而且可能在整个程序中都不一定会使用，可以使用单例模式实现懒加载。</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>小明到了一家大型超市，他拿了一个购物篮开始购物。请设计一个<strong>购物篮管理器</strong>来记录每个添加到购物篮中的商品信息（包括商品名称和购买数量）。在购物完成后，打印出购物篮中的商品清单。（在整个购物过程中，只有一个购物篮实例存在。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShopCarMannage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ShopCarMannage &amp;<span class="title">get_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> ShopCarMannage instance; <span class="comment">// 局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addgood</span><span class="params">(string &amp;name, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (info.<span class="built_in">find</span>(name) == info.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            order.<span class="built_in">push_back</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        info[name] += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : order)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; info.<span class="built_in">at</span>(i) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; info;</span><br><span class="line">    vector&lt;string&gt; order;<span class="comment">//保留顺序</span></span><br><span class="line">    <span class="built_in">ShopCarMannage</span>() &#123;cout &lt;&lt; <span class="string">&quot;constructor called!&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="built_in">ShopCarMannage</span>(<span class="type">const</span> ShopCarMannage &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ShopCarMannage &amp;<span class="keyword">operator</span>=(<span class="type">const</span> ShopCarMannage &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ~<span class="built_in">ShopCarMannage</span>() &#123; cout &lt;&lt; <span class="string">&quot;destructor called!&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ShopCarMannage &amp;instance = ShopCarMannage::<span class="built_in">get_instance</span>();</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; name &gt;&gt; num)</span><br><span class="line">    &#123;</span><br><span class="line">        instance.<span class="built_in">addgood</span>(name, num);</span><br><span class="line">    &#125;</span><br><span class="line">    instance.<span class="built_in">printInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selectsort</title>
      <link href="/posts/3ce50156.html"/>
      <url>/posts/3ce50156.html</url>
      
        <content type="html"><![CDATA[<p>每次选择未排序最小值（选择下标）与待排序第一个值交换</p><p><img src="/posts/3ce50156/da16cfb3088e44f6ad8580f19c3ebe21.gif" alt="da16cfb3088e44f6ad8580f19c3ebe21"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;<span class="comment">//外层循环控制循环次数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> minIndex = i;<span class="comment">//minIndex为未排序最小值下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;<span class="comment">//内层循环选择最小值下标</span></span><br><span class="line"><span class="keyword">if</span> (nums[minIndex] &gt; nums[j])minIndex = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(nums[i], nums[minIndex]);<span class="comment">//交换</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次选择未排序最大值（选择下标）与待排序最后一个值交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;<span class="comment">//外层循环控制循环次数</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> j=<span class="number">1</span>,maxIndex=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(j;j&lt;nums.<span class="built_in">size</span>()-i;j++)&#123;<span class="comment">//内层循环选择最大值下标</span></span><br><span class="line">            <span class="keyword">if</span>(nums[maxIndex]&lt;nums[j])maxIndex=j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">swap</span>(nums[j<span class="number">-1</span>],nums[maxIndex]);<span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 选择排序 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
